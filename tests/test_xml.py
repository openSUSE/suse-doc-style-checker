#

from collections import Counter
from lxml import etree
import pytest
import re
import os
import sdsc


def gatherallids(case):
    """Gather all IDs (xml:id and id) and check if they are unique.

    :param str case: path to testcase
    :return: list of unique IDs
    """
    testname = os.path.basename(case)
    inputtree = etree.parse(case)
    all_ids = inputtree.xpath("//*/@xml:id|//*/@id")
    double_ids = [item for item, count in Counter(all_ids).items()
                  if count > 1]
    if double_ids:
        pytest.fail("Duplicate ID(s) found in case {0!r}: {1}".format(
            testname,
            ", ".join(double_ids)
            ))
    if not all_ids:
        pytest.skip("No tests found in {0}".format(testname))

    return all_ids


def parseresultfile(case, resultxml):
    """Extract complaints from result file

    :param str case: path to testcase
    :param resultxml: XML tree of result file
    :return: Dictionary
    """
    resulttree = etree.fromstring(resultxml)
    complaints = dict()
    currentPartSource = ""
    for elem in resulttree.getiterator():
        if elem.tag == "part":
            currentPartSource = elem.get("source")
            complaints[currentPartSource] = []
        elif elem.tag == "result":
            elemType = elem.get("type", "info")
            if elemType == "info":
                # Not interested in those. They don't have an ID either...
                continue

            withinid = elem.findtext("location/withinid")
            message = elem.find("message")
            if withinid is None:
                withinid = elem.findtext("message/id")
                if withinid is None:
                    pytest.fail("No withinid found")

            formattedMessage = "<no message>"
            if message is not None:
                formattedMessage = etree.tostring(
                    message, method="text", encoding='UTF-8').decode(encoding='UTF-8')
                # Remove excessive whitespace and newlines
                formattedMessage = " ".join(formattedMessage.split()).strip()

            complaints[currentPartSource].append(
                {'id': withinid, 'message': formattedMessage, 'type': elemType})

    return complaints


def isolatewarnings(complaints):
    """Isolate warnings

    :param dict complaints:
    :return: number of unexpected errors or warnings
    """
    errors = 0
    for checkmodule, complaintList in complaints.items():
        for complaint in complaintList:
            expect = complaint["id"].count(
                "sdsc.expect.{0}.{1}".format(complaint["type"],
                                             checkmodule))
            if not expect:
                print("Unexpected {0} {1!r} "
                      "generated by module {2!r} "
                      "for ID {3!r}.".format(complaint["type"],
                                             complaint["message"],
                                             checkmodule,
                                             complaint["id"]),
                      file=sys.stderr)
                errors += 1
    return errors


def searchforerrors(nr_errors, inputids, case, complaints):
    """Checks whether the style checker produces all expected
       information/warning/error messages for terminology
       file-based checks

    :param int nr_errors: existing errors
    :param list inputids: list of existing IDs
    :param str case: path to testcase
    :param dict complaints:
    """
    testname = os.path.basename(case)
    for eid in inputids:
        # Regex for test_sdsc special ids ("stuff.sdsc.expect.warning.a-an.1")
        findExpect = re.search(r'.*sdsc\.expect\.([^.]+)\.([^.]+)(?:\..*|$)', eid)
        if not findExpect:
            continue
        found = False
        if findExpect.group(2) in complaints:
            found = sum(complaint["id"] == eid and complaint["type"] == findExpect.group(
                1) for complaint in complaints[findExpect.group(2)])

        if not found:
            print("Expected {0} for ID {1!r} generated by module {2!r}.".format(
                findExpect.group(1), eid, findExpect.group(2)), file=sys.stderr)
            nr_errors += 1

    if nr_errors > 0:
        pytest.fail(msg="Test {0!r} failed "
                        "with {1} errors!".format(testname, nr_errors),
                    pytrace=False)


def test_xml(xmltestcase):
    """Runs specified testcase and validates the output of all checks.
    The xmltestcase fixture returns all files in tests/cases"""
    nr_errors = 0

    testname = os.path.basename(xmltestcase)
    try:
        resultxml = sdsc.checkOneFile(xmltestcase)
    except etree.Error as error:
        pytest.fail("Syntax error in testcase {0!r}: {1}!".format(testname, error.msg))

    # Parse the input file and gather all ids
    inputids = gatherallids(xmltestcase)

    # Parse the result file and collect ids of errors and warnings
    complaints = parseresultfile(xmltestcase, resultxml)

    # Isolate unexpected warnings
    nr_errors += isolatewarnings(complaints)

    # Now check for missing errors and warnings
    searchforerrors(nr_errors, inputids, xmltestcase, complaints)
